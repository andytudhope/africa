---
title: Language In The Ether
description: 'What does it mean to have an expressive programming language, which compiles down to binary and runs on a shared computer - which is everywhere and nowhere - and which no-one owns? What kinds of metaphors are possible in such a medium? How can we engineer value and meaning for the metamodernist world?'
image: essays/img/book.jpg
---

# Language In The Ether

## Prologue

<div markdown="1" class="center-quote">
_“It is language that shoots up like fire – wrought from a vision of where we must go and from a grip on where we are now” — Antjie Krog_
</div>

A new friend asked me today why and how I had become interested in Ethereum. In order to explain, I had to go back to the year I graduated high school, which was – coincidentally – the year Bitcoin was unleashed onto the world.

## Maths and Metaphors

I set out to study Maths and Physics because I wanted to understand the universe as completely as possible, and those two subjects seemed to offer the most precise, succinct and – frankly – beautiful symbolic language for doing so.

However, Gödel’s incomplete shadow lurks in later years for unsuspecting maths students, and Heisenberg herds his cats with uncertainty through physics buildings late at night. I remember one lecturer with this crazy beard and the sort of _kortbroek_ (short pants) beloved by Eastern Cape sheep farmers, who failed most of the class when we attempted AC theory, and then walked beaming into our introduction to Quantum Mechanics to tell us there was no such thing as an electron.

“An electron is just a probability density wavefront moving through space” he said, gleefully. “It’s a metaphor for a kind of reality we cannot directly perceive”. I was badly hungover and had just failed his AC theory course – which is all about how electrons flow through circuits! – so it took me some time to calm down and appreciate the gravity of his words.

Eventually, I sobered up, grasped what he was really saying and signed up to read a Masters in English Literature, hoping to understand the nature of metaphor itself more deeply. I wrote about [ontological frameworks and singularity](../../academy/yours-sincerely) in the country I grew up in and love. It was an interesting experience: using language in order to take apart the ways in which I look at the world and then put them together again so as to reveal something else, some other story, some strange but fragrant song about how truth is still, always, [singular](https://www.youtube.com/watch?v=dWWEtfLbK1M).


## Though I Sang In My Chains

But, our languages are also constrained. Ambiguous. We cannot think in ways which transcend spacetime – which is what would be necessary to describe the phenomenon fully – because natural language encodes meaning in sound, which propagates linearly through space, and so is always-already bound to time. I was caught in incompleteness once more.

However, the other side of the limited language coin is that something as far-fetched as time travel is impossible only when the concept is arrived at through conventional linguistics. [Arrival](https://www.youtube.com/watch?v=tFMo3UJ4B4g), the sci-fi movie, demonstrated this beautifully. The idea is simple, the result astounding: if you can encode meaning in ways independent of sound and therefore space, you can experience time itself in a radically different manner.

It should be no surprise that the man who made up the alien language – which is circular and [logographic](https://en.wikipedia.org/wiki/Logogram) – is none other than Stephen Wolfram, of [wolfram|alpha](https://www.wolframalpha.com/) fame. Wolfram is a personal hero of mine, calls himself a language designer and has been building the [Wolfram Language](http://www.wolfram.com/language/) for close on ten years, but is really just the latest in a long line of people who spent their lives looking for something like ‘the perfect language’.

## Perfect Language?

The list stretches all the way back to the Ancient Greeks and likely beyond, but the man who really got the search kick-started more recently was named Gottfried Leibniz. Today, maths students around the world use Newton’s Calculus, but Leibniz’s notation, because the man was obsessed with condensing the most meaning he could into the simplest symbols. He spent a lot of his time thinking about how we frame things, which sorts of ontological windows offered the most insight with the least complexity, and a bunch of other things most people never consider.

There were many before Leibniz, like Raymond Lull, all detailed by Umberto Eco in his book [The Search for the Perfect Language](http://inference-review.com/article/the-perfect-language), and many after him: Charles Babbage; Ada Lovelace; Alan Turing; Georg Cantor and Bertram [Russell](https://www.brainpickings.org/2016/05/13/bertrand-russell-mysticism-logic-time/); C. S. Lewis and J. R. R. Tolkien (and the rest of The Inklings); David Hilbert, C. G [Jung](https://www.youtube.com/watch?v=q2YrED9wP2k); and today, people like Diana [Slattery](https://www.youtube.com/watch?v=1KO-NJojN3U) and Stephen Wolfram. However, it was Leibniz who first suggested binary as a candidate for the perfect language. There was something about the mystical nature of 0 and 1 that hooked him.

Don’t get me wrong – especially if you fall down the Diana Slattery, _Xenolinguistics_ rabbit hole – there are many other ideas (apart from plain old binary) about what a perfect language might look like floating around out there. One that I particularly like is Scott Alexander’s idea of [Raikoth](http://slatestarcodex.com/2013/05/06/raikoth-laws-language-and-society/). It would be awesome to live in a world like that, at least in my opinion.

## The Art of Reading

However, back in the “real” world, I like binary as a working candidate. In fact, I have spent a lot of time recently building simple frameworks for ordinary people to express themselves in a language which **can be read** as perfect by anyone who cares to interpret them. To paraphrase Vlad Zamfir, the “can be read” part is in bold because it’s important, but I’ll circle back to it later.

Software offers us a whole new class of languages which differ from natural language in that they use executable text to carry not just thought, but **actions** across the world at the speed of light. Moreover, they are externally verifiable and testable, and that is because – conceptually at least – programming languages are a bridge between mathematics and natural language and compile down to – surprise, surprise – binary, which computers can read.

Why write a novel when I can build interactive, hypertext-based works which rely explicitly (rather than implicitly) on a given reader’s actions? A little further afield, why write a poem about – for instance – wandering as lonely as a cloud, when I can build an immersive experience of just that in virtual reality, replete with believable blasts of wind?

There are a few potential answers to these questions, but the larger point I want to make is that our languages have evolved to encode our myths onto silicon instead of just carbon. Right now, we are imprinting the same patterns that exist in our brains – what we might be tempted to call intelligence – onto a different substrate where, it is arguable, the continued evolution of consciousness will occur most rapidly*.

## Value and Meaning

Now, in order for any language truly to express value – that is, for a language to have any meaning – it needs more than a shared substrate. Language needs a medium through which to flow. Natural language uses carbon as a substrate and us – human beings, the things Tom Robbins once described as “a way water invented to transport itself between rivers” – as its medium. However, programming languages have only a bunch of disparate computer protocols that often don’t play nicely together as their medium. That is, until 2009.

In the same way the programming languages not only carry thought, but action, across vast distances at the speed of light, Bitcoin was the first network and programming language that could not only carry value, but actually **transfer** it across vast distances far more quickly than we have ever been able to do before. That’s awesome in and of itself, but – due to its limited scripting language – transferring value by means of sending [cryptographically meaningful](http://nakamotoinstitute.org/the-playdough-protocols/) messages is pretty much all Bitcoin can do.

## Finally, Ethereum!

Which brings us, at long last, to Ethereum. With a much richer internal scripting language, Ethereum can not only carry and transfer value, it can **define it dynamically** by virtue of autonomous programs running in what can be imagined as a shared, global computer.

Using binary as a candidate for a perfect language works well because what really matters is how our language is **interpreted**, i.e. how we are read by others around us. Well, we have a programmable substrate – silicon – on which binary is the native tongue and we now a programmable medium – Ethereum – which is both a shared, transactional history and a single, global computer capable of running linguistic programs made by humans. Reading from and writing to this network are well-defined operations that allow both humans and programs to communicate more efficiently and securely.

The linguistic possibilities provided by a relatively new substrate running a completely new, consensus-based, cryptographically-secured, general computational medium are endless.

This is where it gets really weird, though, because so far I’ve only talked about language in a more or less human context. However, the programs on Ethereum can also talk to other programs and can – because they share the same, consensus-backed computer – transact between themselves. My good friend Simon de la Rouviere had this to [say](https://medium.com/@ConsenSys/love-the-end-of-the-world-and-the-benefits-of-verifiable-computing-1697658e3143):

> “It’s doubtful that programs will develop the desire to connect for the sake of it (like we do), unless we program them to do it. However, the benefits of knowing that a computation was verifiably done is like inventing religion for programs. Like the biological desire to know what’s going on in others’ minds, with verifiable computing protocols, a program will know the minds of other programs. Except, unlike biology, where it is imperfect, it will know exactly the state and processing capability. There’s no longer this idea of servers of data and logic connected disparately through the network.”

Because [blockchains fuse data and networks](https://vimeo.com/161183966) – i.e. everywhere there is data, there is network and everywhere there is network, there is data – and provide the results transparently to everyone, programming languages **can be read** by other programs and human beings in an essentially perfect way, if you take the term to indicate global consensus about the deterministic output of the program or account being read.

## Conclusion

We live in a time where it is possible to tell stories that not only carry, but transfer, real value. It is therefore incumbent upon us to think more carefully than ever before about the forms we choose for our narratives, and the means by which we encode them into the world. Such stories, created in languages that compile down to binary run on a global computer, can literally alter the shared notion of history we are building together.

If the thought of machines that can communicate in a language [approaching the perfect](https://vimeo.com/36579366), or global computers that are everywhere and nowhere and can’t be switched off, or the advent of Artificial General Intelligence in such a context worries you, don’t be alarmed, you’re in good company. However, it is worth noting that a system like AlphaGo didn’t end up destroying the game (read: art form) of Go by beating the world champion, Lee Sedol.

Rather, in beating him, AlphaGo revealed a [new range of artistic possibilities](https://deepmind.com/blog/exploring-mysteries-alphago/) never before considered by humans. Moreover, through ongoing collaborations with the world’s best players, AlphaGo – and the humans behind it – has advanced the game more in a year than in the last two thousand. We are learning together whole new ways to [play](https://www.youtube.com/watch?v=9yVOd9TXNks).

We need always to find constructive ways to use the tools we discover – that is the true nature of invention. I would argue that Satoshi Nakamoto set in motion the discovery of a whole set of new linguistic tools that we can use to help society reimagine what is valuable and how that is expressed, those two most fundamentally human actions. Furthermore, I would argue that trustless means of ensuring equitable distributions of value **amongst people** is – in fact – a prerequisite for a functional society that coexists with things like Artificial General Intelligence.

It’s heady stuff, and I drank the koolaid years ago, so please forgive my inevitable blind spots. I don’t feel much different from that idealistic kid consumed by a desire to know it all, except that I no longer think in surface metaphors. Now it’s something more like an old story I once heard: each thought a point of light; each containing a reflection of all the others, and themselves; each unutterably unique; each supporting the other by means of what is shared.

---

*I don’t want to get into the implied ethics of this, I just want to note that it is a very strong possibility, and therefore well worth [thinking about](https://waitbutwhy.com/2015/01/artificial-intelligence-revolution-1.html).

**The formal term is “[Turing-complete](https://en.wikipedia.org/wiki/Turing_completeness)”.

---

## Appendix

There are a lot of links in this paper which I doubt most people will have the time to follow, so allow me to highlight just one of them, Gregory Chaitin’s article on [The Perfect Language](http://inference-review.com/article/the-perfect-language). I suggest you read it for yourself, but it’s very long, so here are some of the key, non-technical passages for people in a rush:

> “The crucial point is that knowing this language would be like having a key to universal knowledge. If you’re a theologian, it would bring you closer, very close, to God’s thoughts, which is dangerous. If you’re a magician, it would give you magical powers. If you’re a linguist, it would tell you the original, pure, uncorrupted language from which all languages descend […]

> Leibniz formulated a version of the search for the perfect language, which was firmly grounded in the magical, theological original idea, but which is also fit for consumption nowadays, that is, acceptable to modern ears, to contemporary scientists. This is a universal language, which he called the **characteristica universalis**, that was supposed to come with a crucial calculus ratiocinator.

> The idea is to reduce reasoning to calculation, to computation, because the most certain thing is that 2 + 5 = 7, and what is this if not a calculation? If two people have an intellectual dispute, Leibniz remarked, instead of dueling they could just sit down and say, “Gentlemen, let us compute!” and get the correct answer, and find out who was right […]

> [… While, Gödel in 1931 – and Alan Turing in 1936 – showed that you can’t have a perfect language for _mathematics_, in Turing’s work] you get another proof, a deeper proof of incompleteness, but you also get a kind of completeness.

> You find a perfect language.

> There is no perfect language for mathematical reasoning. Gödel showed that in 1931, and Turing showed it again in 1936. But what Turing also showed in 1936 is that there are perfect languages, not for mathematical reasoning, but for **computation**, for specifying algorithms. What Turing discovered in 1936 is that there’s a kind of completeness called universality and that there are universal Turing machines and universal programming languages.

> What universal means, what a universal programming language or a universal Turing machine is, is a language in which every possible algorithm can be written. On the one hand, Turing showed us in a deeper way that any language for mathematical reasoning has to be incomplete, but on the other hand, he showed us that languages for computation can be universal, which is just a synonym for completeness. There are perfect languages for computation, for writing algorithms, even though there aren’t any perfect languages for mathematical reasoning […]

> Algorithmic information theory (AIT) goes further than Turing, and picks out, from Turing’s universal languages, maximally expressive programming languages […]

> AIT has the notion of a maximally expressive programming language in which programs are maximally compact, and deals with a very basic complexity concept, which is the size of the smallest program to calculate something.

> Now we have a better notion of perfection. Universal programming languages are not all equally good. We concentrate on a subset, comprising the ones that enable us to write the most concise programs […]

> What we’re asking is, **how many yes/no decisions did God have to make to create something?** — which is obviously a rather basic question to ask, if you consider that God is calculating the universe. I’m giving you a medieval perspective on these modern developments.”
